/**
 * PowerReview Threat Intelligence Monitor
 * Monitors real threat feeds and automatically generates security checks
 */

export interface ThreatSource {
    id: string;
    name: string;
    url: string;
    frequency: number; // milliseconds
    parser: (data: any) => Promise<ThreatIndicator[]>;
    headers?: Record<string, string>;
    lastChecked?: Date;
    isActive: boolean;
    rateLimitDelay?: number;
}

export interface ThreatIndicator {
    id: string;
    type: 'cve' | 'ioc' | 'advisory' | 'signature' | 'campaign';
    severity: 'critical' | 'high' | 'medium' | 'low';
    title: string;
    description: string;
    affectedProducts: string[];
    indicators: string[];
    mitigation?: string;
    detectedAt: Date;
    source: string;
    references: string[];
    tags: string[];
    confidence: number; // 0-100
}

export interface SecurityCheck {
    checkId: string;
    name: string;
    description: string;
    category: 'identity' | 'email' | 'collaboration' | 'data' | 'device' | 'infrastructure';
    service: 'azuread' | 'exchange' | 'sharepoint' | 'teams' | 'defender' | 'compliance';
    severity: 'critical' | 'high' | 'medium' | 'low';
    powershellScript: string;
    expectedResult: any;
    remediationScript?: string;
    addedDate: Date;
    threatSource: string;
    threatId: string;
    autoGenerated: boolean;
}

export class ThreatIntelligenceMonitor {
    private sources: ThreatSource[] = [];
    private indicators: Map<string, ThreatIndicator> = new Map();
    private securityChecks: Map<string, SecurityCheck> = new Map();
    private webhookUrls: string[] = [];
    private isMonitoring: boolean = false;
    private eventEmitter = new EventTarget();

    constructor() {
        this.initializeSources();
    }

    private initializeSources() {
        this.sources = [
            // CISA Known Exploited Vulnerabilities
            {
                id: 'cisa_kev',
                name: 'CISA Known Exploited Vulnerabilities',
                url: 'https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json',
                frequency: 3600000, // 1 hour
                parser: this.parseCISAFeed.bind(this),
                isActive: true,
                rateLimitDelay: 5000
            },
            
            // Microsoft Security Response Center
            {
                id: 'microsoft_advisories',
                name: 'Microsoft Security Advisories',
                url: 'https://api.msrc.microsoft.com/sug/v2.0/en-US/vulnerability',
                frequency: 14400000, // 4 hours
                parser: this.parseMicrosoftAdvisories.bind(this),
                headers: {
                    'Accept': 'application/json',
                    'User-Agent': 'PowerReview-ThreatIntel/1.0'
                },
                isActive: true,
                rateLimitDelay: 10000
            },

            // NIST National Vulnerability Database
            {
                id: 'nvd_cves',
                name: 'NIST National Vulnerability Database',
                url: 'https://services.nvd.nist.gov/rest/json/cves/2.0',
                frequency: 21600000, // 6 hours
                parser: this.parseNVDFeed.bind(this),
                headers: {
                    'Accept': 'application/json'
                },
                isActive: true,
                rateLimitDelay: 15000
            },

            // AlienVault OTX (Open Threat Exchange)
            {
                id: 'otx_indicators',
                name: 'AlienVault Open Threat Exchange',
                url: 'https://otx.alienvault.com/api/v1/pulses/subscribed',
                frequency: 7200000, // 2 hours
                parser: this.parseOTXFeed.bind(this),
                headers: {
                    'X-OTX-API-KEY': process.env.OTX_API_KEY || '',
                    'Accept': 'application/json'
                },
                isActive: !!process.env.OTX_API_KEY,
                rateLimitDelay: 5000
            },

            // Abuse.ch URLhaus
            {
                id: 'abuse_urlhaus',
                name: 'Abuse.ch URLhaus',
                url: 'https://urlhaus-api.abuse.ch/v1/urls/recent/',
                frequency: 3600000, // 1 hour
                parser: this.parseURLhausFeed.bind(this),
                isActive: true,
                rateLimitDelay: 3000
            },

            // Hybrid Analysis Recent Samples
            {
                id: 'hybrid_analysis',
                name: 'Hybrid Analysis',
                url: 'https://www.hybrid-analysis.com/api/v2/feed/latest',
                frequency: 7200000, // 2 hours
                parser: this.parseHybridAnalysisFeed.bind(this),
                headers: {
                    'api-key': process.env.HYBRID_ANALYSIS_API_KEY || '',
                    'Accept': 'application/json'
                },
                isActive: !!process.env.HYBRID_ANALYSIS_API_KEY,
                rateLimitDelay: 10000
            }
        ];
    }

    public async startMonitoring(): Promise<void> {
        if (this.isMonitoring) return;
        
        this.isMonitoring = true;
        console.log('üîç Starting PowerReview Threat Intelligence Monitoring...');
        
        // Initial check of all sources
        await this.performInitialScan();
        
        // Schedule regular monitoring
        this.scheduleMonitoring();
        
        // Start real-time event processing
        this.startEventProcessing();
        
        console.log('‚úÖ Threat Intelligence Monitoring started successfully');
    }

    public stopMonitoring(): void {
        this.isMonitoring = false;
        console.log('üõë Threat Intelligence Monitoring stopped');
    }

    private async performInitialScan(): Promise<void> {
        console.log('üì° Performing initial threat intelligence scan...');
        
        const activeSourcesPromises = this.sources
            .filter(source => source.isActive)
            .map(source => this.safeFetchFromSource(source));
        
        const results = await Promise.allSettled(activeSourcesPromises);
        
        let successCount = 0;
        let errorCount = 0;
        
        results.forEach((result, index) => {
            if (result.status === 'fulfilled') {
                successCount++;
            } else {
                errorCount++;
                console.error(`‚ùå Initial scan failed for ${this.sources[index].name}:`, result.reason);
            }
        });
        
        console.log(`üìä Initial scan complete: ${successCount} sources successful, ${errorCount} errors`);
    }

    private scheduleMonitoring(): void {
        this.sources
            .filter(source => source.isActive)
            .forEach(source => {
                // Stagger initial checks to avoid rate limiting
                const initialDelay = Math.random() * 60000; // 0-60 seconds
                
                setTimeout(() => {
                    this.scheduleSourceMonitoring(source);
                }, initialDelay);
            });
    }

    private scheduleSourceMonitoring(source: ThreatSource): void {
        const checkSource = async () => {
            if (!this.isMonitoring) return;
            
            try {
                await this.safeFetchFromSource(source);
            } catch (error) {
                console.error(`‚ùå Scheduled check failed for ${source.name}:`, error);
                this.emitError(source.name, error);
            }
            
            // Schedule next check
            if (this.isMonitoring) {
                setTimeout(checkSource, source.frequency);
            }
        };
        
        // Start the monitoring loop
        setTimeout(checkSource, source.frequency);
    }

    private async safeFetchFromSource(source: ThreatSource): Promise<void> {
        try {
            // Rate limiting
            if (source.rateLimitDelay) {
                await this.delay(source.rateLimitDelay);
            }
            
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
            
            const response = await fetch(source.url, {
                method: 'GET',
                headers: {
                    'User-Agent': 'PowerReview-ThreatIntel/1.0',
                    ...source.headers
                },
                signal: controller.signal
            });
            
            clearTimeout(timeoutId);
            
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            const indicators = await source.parser(data);
            
            console.log(`üì° ${source.name}: Found ${indicators.length} new indicators`);
            
            // Process each indicator
            for (const indicator of indicators) {
                await this.processIndicator(indicator);
            }
            
            source.lastChecked = new Date();
            this.emitSourceUpdate(source, indicators.length);
            
        } catch (error) {
            console.error(`‚ùå Error fetching from ${source.name}:`, error);
            this.emitError(source.name, error);
        }
    }

    private async processIndicator(indicator: ThreatIndicator): Promise<void> {
        // Check if we already have this indicator
        if (this.indicators.has(indicator.id)) {
            return;
        }
        
        // Store the indicator
        this.indicators.set(indicator.id, indicator);
        
        // Generate security check if relevant to M365
        if (this.isMicrosoft365Relevant(indicator)) {
            const securityCheck = await this.generateSecurityCheck(indicator);
            if (securityCheck) {
                this.securityChecks.set(securityCheck.checkId, securityCheck);
                await this.deploySecurityCheck(securityCheck);
            }
        }
        
        // Emit new threat event
        this.emitNewThreat(indicator);
        
        // Send alerts for high-priority threats
        if (indicator.severity === 'critical' || indicator.severity === 'high') {
            await this.sendThreatAlert(indicator);
        }
    }

    // Parsers for different threat feeds
    private async parseCISAFeed(data: any): Promise<ThreatIndicator[]> {
        if (!data.vulnerabilities) return [];
        
        return data.vulnerabilities
            .filter((vuln: any) => this.isRecentThreat(vuln.dateAdded, 30)) // Last 30 days
            .map((vuln: any) => ({
                id: `cisa-${vuln.cveID}`,
                type: 'cve' as const,
                severity: vuln.knownRansomwareCampaignUse === 'Known' ? 'critical' as const : 'high' as const,
                title: `CISA KEV: ${vuln.cveID}`,
                description: vuln.shortDescription,
                affectedProducts: [vuln.product],
                indicators: [vuln.cveID],
                mitigation: vuln.requiredAction,
                detectedAt: new Date(vuln.dateAdded),
                source: 'CISA',
                references: [
                    `https://nvd.nist.gov/vuln/detail/${vuln.cveID}`,
                    'https://www.cisa.gov/known-exploited-vulnerabilities-catalog'
                ],
                tags: ['cve', 'known-exploited', vuln.knownRansomwareCampaignUse === 'Known' ? 'ransomware' : 'vulnerability'],
                confidence: 95
            }));
    }

    private async parseMicrosoftAdvisories(data: any): Promise<ThreatIndicator[]> {
        if (!data.value) return [];
        
        return data.value
            .filter((advisory: any) => this.isMicrosoft365Advisory(advisory))
            .filter((advisory: any) => this.isRecentThreat(advisory.releaseDate, 60)) // Last 60 days
            .map((advisory: any) => ({
                id: `msrc-${advisory.id}`,
                type: 'advisory' as const,
                severity: this.mapMicrosoftSeverity(advisory.severity),
                title: advisory.title,
                description: advisory.description,
                affectedProducts: advisory.affectedProducts || ['Microsoft 365'],
                indicators: [advisory.id],
                detectedAt: new Date(advisory.releaseDate),
                source: 'Microsoft',
                references: [advisory.url || `https://msrc.microsoft.com/update-guide/vulnerability/${advisory.id}`],
                tags: ['microsoft', 'advisory', advisory.severity?.toLowerCase() || 'unknown'],
                confidence: 98
            }));
    }

    private async parseNVDFeed(data: any): Promise<ThreatIndicator[]> {
        if (!data.vulnerabilities) return [];
        
        return data.vulnerabilities
            .filter((vuln: any) => this.isMicrosoft365CVE(vuln.cve))
            .filter((vuln: any) => this.isRecentThreat(vuln.cve.published, 14)) // Last 14 days
            .map((vuln: any) => ({
                id: `nvd-${vuln.cve.id}`,
                type: 'cve' as const,
                severity: this.mapCVSSSeverity(vuln.cve.metrics?.cvssMetricV31?.[0]?.cvssData?.baseScore),
                title: `${vuln.cve.id}: ${vuln.cve.descriptions?.[0]?.value?.substring(0, 100) || 'No description'}...`,
                description: vuln.cve.descriptions?.[0]?.value || 'No description available',
                affectedProducts: this.extractAffectedProducts(vuln.cve),
                indicators: [vuln.cve.id],
                detectedAt: new Date(vuln.cve.published),
                source: 'NVD',
                references: vuln.cve.references?.map((ref: any) => ref.url) || [],
                tags: ['cve', 'nvd', ...(vuln.cve.descriptions?.[0]?.value?.toLowerCase().includes('microsoft') ? ['microsoft'] : [])],
                confidence: 90
            }));
    }

    private async parseOTXFeed(data: any): Promise<ThreatIndicator[]> {
        if (!data.results) return [];
        
        return data.results
            .filter((pulse: any) => this.isRelevantOTXPulse(pulse))
            .filter((pulse: any) => this.isRecentThreat(pulse.created, 7)) // Last 7 days
            .map((pulse: any) => ({
                id: `otx-${pulse.id}`,
                type: 'ioc' as const,
                severity: this.mapOTXSeverity(pulse.tags),
                title: pulse.name,
                description: pulse.description,
                affectedProducts: ['Microsoft 365'],
                indicators: pulse.indicators?.map((ind: any) => ind.indicator) || [],
                detectedAt: new Date(pulse.created),
                source: 'AlienVault OTX',
                references: [pulse.permalink],
                tags: pulse.tags || [],
                confidence: 75
            }));
    }

    private async parseURLhausFeed(data: any): Promise<ThreatIndicator[]> {
        if (!data.urls) return [];
        
        return data.urls
            .filter((url: any) => this.isOfficeRelatedURL(url))
            .filter((url: any) => this.isRecentThreat(url.date_added, 1)) // Last 24 hours
            .map((url: any) => ({
                id: `urlhaus-${url.id}`,
                type: 'ioc' as const,
                severity: url.threat === 'malware_download' ? 'high' as const : 'medium' as const,
                title: `Malicious URL: ${url.url_status}`,
                description: `URLhaus detected malicious URL serving ${url.payloads?.[0]?.file_type || 'unknown'} payload`,
                affectedProducts: ['Microsoft Office', 'Microsoft 365'],
                indicators: [url.url, ...(url.payloads?.map((p: any) => p.sha256_hash) || [])],
                detectedAt: new Date(url.date_added),
                source: 'Abuse.ch',
                references: [`https://urlhaus.abuse.ch/url/${url.id}/`],
                tags: ['malware', 'url', url.threat, ...(url.tags || [])],
                confidence: 85
            }));
    }

    private async parseHybridAnalysisFeed(data: any): Promise<ThreatIndicator[]> {
        if (!data.data) return [];
        
        return data.data
            .filter((sample: any) => this.isOfficeRelatedSample(sample))
            .filter((sample: any) => this.isRecentThreat(sample.submit_time, 1)) // Last 24 hours
            .map((sample: any) => ({
                id: `hybrid-${sample.sha256}`,
                type: 'ioc' as const,
                severity: sample.verdict === 'malicious' ? 'high' as const : 'medium' as const,
                title: `Malicious Document: ${sample.submit_name}`,
                description: `Hybrid Analysis detected ${sample.file_type} with threat score ${sample.threat_score}/100`,
                affectedProducts: ['Microsoft Office', 'Microsoft 365'],
                indicators: [sample.sha256, sample.md5],
                detectedAt: new Date(sample.submit_time),
                source: 'Hybrid Analysis',
                references: [`https://www.hybrid-analysis.com/sample/${sample.sha256}`],
                tags: ['malware', 'document', sample.file_type, sample.verdict],
                confidence: sample.threat_score || 50
            }));
    }

    private async generateSecurityCheck(indicator: ThreatIndicator): Promise<SecurityCheck | null> {
        const checkId = `auto_${indicator.type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        
        switch (indicator.type) {
            case 'cve':
                return this.generateCVECheck(indicator, checkId);
            case 'advisory':
                return this.generateAdvisoryCheck(indicator, checkId);
            case 'ioc':
                return this.generateIOCCheck(indicator, checkId);
            default:
                return null;
        }
    }

    private generateCVECheck(indicator: ThreatIndicator, checkId: string): SecurityCheck {
        const powershellScript = `
# PowerReview Auto-Generated Check for ${indicator.id}
# Generated: ${new Date().toISOString()}
# Source: ${indicator.source}

$checkResult = @{
    CheckId = "${checkId}"
    ThreatId = "${indicator.id}"
    CheckType = "CVE_MITIGATION"
    Timestamp = (Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ")
}

try {
    # Check for recent security updates
    $recentUpdates = Get-HotFix | Where-Object { 
        $_.Description -like "*Security*" -and 
        $_.InstalledOn -gt (Get-Date).AddDays(-30) 
    }
    
    # Check Windows Defender status
    $defenderStatus = Get-MpComputerStatus -ErrorAction SilentlyContinue
    
    # Check for specific CVE mitigations
    $cveId = "${indicator.id}"
    $knownMitigations = @()
    
    # Check registry for known mitigations (example)
    if ($cveId -match "CVE-2024-\\d+") {
        $regPath = "HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\QualityCompat"
        if (Test-Path $regPath) {
            $mitigations = Get-ItemProperty $regPath -ErrorAction SilentlyContinue
            if ($mitigations) {
                $knownMitigations += "Registry mitigations detected"
            }
        }
    }
    
    $checkResult.Status = "SUCCESS"
    $checkResult.Data = @{
        CVE = $cveId
        RecentSecurityUpdates = $recentUpdates.Count
        LatestUpdate = ($recentUpdates | Sort-Object InstalledOn -Descending | Select-Object -First 1)?.InstalledOn
        DefenderEnabled = $defenderStatus.AntivirusEnabled
        DefenderUpToDate = $defenderStatus.AntivirusSignatureAge -lt 7
        KnownMitigations = $knownMitigations
        SystemInfo = @{
            OS = (Get-CimInstance Win32_OperatingSystem).Caption
            Version = (Get-CimInstance Win32_OperatingSystem).Version
            Architecture = $env:PROCESSOR_ARCHITECTURE
        }
    }
    
    # Determine if system appears vulnerable
    $isVulnerable = $false
    if ($recentUpdates.Count -eq 0) { $isVulnerable = $true }
    if (-not $defenderStatus.AntivirusEnabled) { $isVulnerable = $true }
    if ($defenderStatus.AntivirusSignatureAge -gt 7) { $isVulnerable = $true }
    
    $checkResult.Vulnerable = $isVulnerable
    $checkResult.Recommendation = if ($isVulnerable) {
        "System may be vulnerable to ${indicator.id}. Apply latest security updates and ensure Windows Defender is enabled and up-to-date."
    } else {
        "System appears to have mitigations in place for ${indicator.id}."
    }
    
} catch {
    $checkResult.Status = "ERROR"
    $checkResult.Error = $_.Exception.Message
    $checkResult.Vulnerable = $null
}

return $checkResult | ConvertTo-Json -Depth 4
        `.trim();

        return {
            checkId,
            name: `CVE Check: ${indicator.id}`,
            description: `Automated vulnerability check for ${indicator.id}: ${indicator.description.substring(0, 200)}...`,
            category: 'infrastructure',
            service: 'defender',
            severity: indicator.severity,
            powershellScript,
            expectedResult: { Vulnerable: false },
            remediationScript: `
# Remediation for ${indicator.id}
# ${indicator.mitigation || 'Apply latest security updates'}

# Update Windows Defender signatures
Update-MpSignature -UpdateSource MicrosoftUpdateServer

# Check for and install security updates
if (Get-Module -ListAvailable -Name PSWindowsUpdate) {
    Import-Module PSWindowsUpdate
    Get-WindowsUpdate -KBArticleID "*Security*" -Install -AcceptAll -AutoReboot
} else {
    Write-Host "PSWindowsUpdate module not available. Please install Windows Updates manually."
}
            `.trim(),
            addedDate: new Date(),
            threatSource: indicator.source,
            threatId: indicator.id,
            autoGenerated: true
        };
    }

    private generateAdvisoryCheck(indicator: ThreatIndicator, checkId: string): SecurityCheck {
        const powershellScript = `
# PowerReview Auto-Generated Check for Microsoft Advisory ${indicator.id}
# Generated: ${new Date().toISOString()}

$checkResult = @{
    CheckId = "${checkId}"
    AdvisoryId = "${indicator.id}"
    CheckType = "MICROSOFT_ADVISORY"
    Timestamp = (Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ")
}

try {
    # Connect to Microsoft Graph (if available)
    if (Get-Module -ListAvailable -Name Microsoft.Graph) {
        try {
            Connect-MgGraph -Scopes "SecurityEvents.Read.All" -ErrorAction SilentlyContinue
            $graphConnected = $true
        } catch {
            $graphConnected = $false
        }
    } else {
        $graphConnected = $false
    }
    
    # Check M365 security configuration
    $securityConfig = @{
        MFAStatus = $null
        ConditionalAccess = $null
        SecurityDefaults = $null
        DefenderStatus = $null
    }
    
    if ($graphConnected) {
        # Get conditional access policies
        try {
            $caPolicies = Get-MgConditionalAccessPolicy -ErrorAction SilentlyContinue
            $securityConfig.ConditionalAccess = @{
                TotalPolicies = $caPolicies.Count
                EnabledPolicies = ($caPolicies | Where-Object { $_.State -eq "enabled" }).Count
            }
        } catch {
            $securityConfig.ConditionalAccess = "Access Denied"
        }
    }
    
    # Check local Defender configuration
    try {
        $defenderStatus = Get-MpComputerStatus -ErrorAction SilentlyContinue
        $securityConfig.DefenderStatus = @{
            AntivirusEnabled = $defenderStatus.AntivirusEnabled
            RealTimeProtectionEnabled = $defenderStatus.RealTimeProtectionEnabled
            SignatureAge = $defenderStatus.AntivirusSignatureAge
            LastFullScan = $defenderStatus.FullScanAge
        }
    } catch {
        $securityConfig.DefenderStatus = "Not Available"
    }
    
    $checkResult.Status = "SUCCESS"
    $checkResult.Data = $securityConfig
    $checkResult.GraphConnected = $graphConnected
    
    # Assess risk based on advisory
    $riskFactors = @()
    if (-not $defenderStatus.AntivirusEnabled) { $riskFactors += "Defender not enabled" }
    if ($defenderStatus.AntivirusSignatureAge -gt 7) { $riskFactors += "Outdated signatures" }
    if ($securityConfig.ConditionalAccess.EnabledPolicies -lt 1) { $riskFactors += "No conditional access policies" }
    
    $checkResult.RiskFactors = $riskFactors
    $checkResult.RiskLevel = if ($riskFactors.Count -gt 2) { "HIGH" } 
                            elseif ($riskFactors.Count -gt 0) { "MEDIUM" } 
                            else { "LOW" }
    
} catch {
    $checkResult.Status = "ERROR"
    $checkResult.Error = $_.Exception.Message
}

return $checkResult | ConvertTo-Json -Depth 4
        `.trim();

        return {
            checkId,
            name: `Microsoft Advisory: ${indicator.title}`,
            description: indicator.description.substring(0, 200) + '...',
            category: 'identity',
            service: 'azuread',
            severity: indicator.severity,
            powershellScript,
            expectedResult: { RiskLevel: "LOW" },
            addedDate: new Date(),
            threatSource: indicator.source,
            threatId: indicator.id,
            autoGenerated: true
        };
    }

    private generateIOCCheck(indicator: ThreatIndicator, checkId: string): SecurityCheck {
        const iocList = indicator.indicators.slice(0, 10); // Limit to first 10 IOCs
        const powershellScript = `
# PowerReview Auto-Generated IOC Check for ${indicator.title}
# Generated: ${new Date().toISOString()}

$checkResult = @{
    CheckId = "${checkId}"
    ThreatTitle = "${indicator.title}"
    CheckType = "IOC_DETECTION"
    Timestamp = (Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ")
}

$iocs = @(${iocList.map(ioc => `"${ioc}"`).join(', ')})

try {
    $findings = @()
    
    # Check for file-based IOCs (hashes)
    foreach ($ioc in $iocs) {
        if ($ioc -match "^[a-fA-F0-9]{32}$|^[a-fA-F0-9]{40}$|^[a-fA-F0-9]{64}$") {
            # This is a hash - check recent file events
            $hashFindings = @()
            
            # Check downloads folder
            $downloadsPath = [Environment]::GetFolderPath("UserProfile") + "\\Downloads"
            if (Test-Path $downloadsPath) {
                $recentFiles = Get-ChildItem $downloadsPath -Recurse -File | 
                    Where-Object { $_.LastWriteTime -gt (Get-Date).AddDays(-7) }
                
                foreach ($file in $recentFiles) {
                    try {
                        $fileHash = Get-FileHash $file.FullName -Algorithm SHA256 -ErrorAction SilentlyContinue
                        if ($fileHash.Hash -eq $ioc.ToUpper()) {
                            $hashFindings += @{
                                File = $file.FullName
                                Hash = $fileHash.Hash
                                LastModified = $file.LastWriteTime
                                Size = $file.Length
                            }
                        }
                    } catch {
                        # Skip files that can't be hashed
                    }
                }
            }
            
            if ($hashFindings.Count -gt 0) {
                $findings += @{
                    IOC = $ioc
                    Type = "File Hash"
                    Matches = $hashFindings
                }
            }
        }
        
        # Check for URL-based IOCs
        if ($ioc -match "^https?://") {
            # Check browser history (simplified check)
            $urlFindings = @()
            
            # Check IE/Edge history
            $historyPath = "$env:LOCALAPPDATA\\Microsoft\\Windows\\WebCache\\WebCacheV*.dat"
            if (Test-Path $historyPath) {
                # Note: In production, this would use proper browser history parsing
                $urlFindings += @{
                    Browser = "Edge/IE"
                    Note = "URL-based IOC detected - manual browser history review recommended"
                }
            }
            
            if ($urlFindings.Count -gt 0) {
                $findings += @{
                    IOC = $ioc
                    Type = "URL"
                    Matches = $urlFindings
                }
            }
        }
    }
    
    # Check Windows Event Logs for suspicious activity
    $eventFindings = @()
    try {
        $suspiciousEvents = Get-WinEvent -FilterHashtable @{
            LogName = 'Security'
            StartTime = (Get-Date).AddDays(-7)
            ID = 4625, 4648, 4672  # Failed logon, explicit credential use, special privileges
        } -MaxEvents 100 -ErrorAction SilentlyContinue
        
        if ($suspiciousEvents.Count -gt 10) {
            $eventFindings += "High number of security events detected ($($suspiciousEvents.Count))"
        }
    } catch {
        # Event log access may be restricted
    }
    
    $checkResult.Status = "SUCCESS"
    $checkResult.Data = @{
        IOCs_Checked = $iocs.Count
        Findings = $findings
        EventLogFindings = $eventFindings
        LastChecked = Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ"
    }
    
    $checkResult.ThreatDetected = $findings.Count -gt 0
    $checkResult.FindingsCount = $findings.Count
    
    if ($findings.Count -gt 0) {
        $checkResult.Recommendation = "IMMEDIATE ACTION REQUIRED: Threat indicators detected on system. Isolate machine and perform full malware scan."
    } else {
        $checkResult.Recommendation = "No threat indicators detected. Continue monitoring."
    }
    
} catch {
    $checkResult.Status = "ERROR"
    $checkResult.Error = $_.Exception.Message
}

return $checkResult | ConvertTo-Json -Depth 5
        `.trim();

        return {
            checkId,
            name: `IOC Detection: ${indicator.title}`,
            description: `Check for indicators of compromise related to: ${indicator.description.substring(0, 150)}...`,
            category: 'device',
            service: 'defender',
            severity: indicator.severity,
            powershellScript,
            expectedResult: { ThreatDetected: false },
            remediationScript: `
# Immediate response for detected IOCs
# Isolate system if threats are confirmed

# Run full system scan
Start-MpScan -ScanType FullScan

# Update all signatures
Update-MpSignature

# Check for additional threats
$fullScanResults = Get-MpThreatDetection
if ($fullScanResults) {
    Write-Host "Additional threats detected. Immediate security team notification required."
    # In production, this would trigger incident response
}
            `.trim(),
            addedDate: new Date(),
            threatSource: indicator.source,
            threatId: indicator.id,
            autoGenerated: true
        };
    }

    private async deploySecurityCheck(check: SecurityCheck): Promise<void> {
        try {
            // In production, this would integrate with your assessment engine
            console.log(`üöÄ Deploying new security check: ${check.name}`);
            
            // Store in database
            await this.storeSecurityCheck(check);
            
            // Notify assessment engine
            this.emitNewSecurityCheck(check);
            
            console.log(`‚úÖ Security check deployed: ${check.checkId}`);
            
        } catch (error) {
            console.error(`‚ùå Failed to deploy security check ${check.checkId}:`, error);
        }
    }

    private async sendThreatAlert(indicator: ThreatIndicator): Promise<void> {
        const alert = {
            type: 'threat_detected',
            severity: indicator.severity,
            title: indicator.title,
            description: indicator.description,
            source: indicator.source,
            indicators: indicator.indicators,
            affectedProducts: indicator.affectedProducts,
            confidence: indicator.confidence,
            timestamp: new Date().toISOString(),
            actionRequired: indicator.severity === 'critical' || indicator.severity === 'high'
        };

        // Send to configured webhooks
        const webhookPromises = this.webhookUrls.map(url => 
            this.sendWebhookAlert(url, alert)
        );
        
        await Promise.allSettled(webhookPromises);
        
        // Store alert for dashboard
        await this.storeAlert(alert);
    }

    // Helper methods
    private isRecentThreat(dateString: string, daysBack: number): boolean {
        const threatDate = new Date(dateString);
        const cutoffDate = new Date();
        cutoffDate.setDate(cutoffDate.getDate() - daysBack);
        return threatDate > cutoffDate;
    }

    private isMicrosoft365Relevant(indicator: ThreatIndicator): boolean {
        const m365Keywords = [
            'microsoft 365', 'office 365', 'exchange online', 'sharepoint online',
            'microsoft teams', 'onedrive', 'azure ad', 'azure active directory',
            'microsoft office', 'outlook', 'word', 'excel', 'powerpoint'
        ];
        
        const searchText = `${indicator.title} ${indicator.description} ${indicator.affectedProducts.join(' ')}`.toLowerCase();
        return m365Keywords.some(keyword => searchText.includes(keyword));
    }

    private isMicrosoft365Advisory(advisory: any): boolean {
        if (!advisory.affectedProducts) return false;
        
        const m365Products = advisory.affectedProducts.some((product: string) => {
            const lowerProduct = product.toLowerCase();
            return lowerProduct.includes('microsoft 365') || 
                   lowerProduct.includes('office 365') ||
                   lowerProduct.includes('exchange online') ||
                   lowerProduct.includes('sharepoint online') ||
                   lowerProduct.includes('teams');
        });
        
        return m365Products;
    }

    private isMicrosoft365CVE(cve: any): boolean {
        const description = cve.descriptions?.[0]?.value?.toLowerCase() || '';
        const m365Keywords = [
            'microsoft office', 'microsoft 365', 'exchange server', 'sharepoint',
            'microsoft teams', 'onedrive', 'azure active directory'
        ];
        
        return m365Keywords.some(keyword => description.includes(keyword));
    }

    private isOfficeRelatedURL(url: any): boolean {
        const urlString = url.url?.toLowerCase() || '';
        const payloads = url.payloads || [];
        
        // Check for Office file extensions in URL
        const officeExtensions = ['.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx', '.rtf'];
        const hasOfficeExtension = officeExtensions.some(ext => urlString.includes(ext));
        
        // Check payloads for Office file types
        const hasOfficePayload = payloads.some((payload: any) => 
            payload.file_type && ['doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx'].includes(payload.file_type.toLowerCase())
        );
        
        return hasOfficeExtension || hasOfficePayload;
    }

    private isOfficeRelatedSample(sample: any): boolean {
        const filename = sample.submit_name?.toLowerCase() || '';
        const filetype = sample.file_type?.toLowerCase() || '';
        
        const officeTypes = ['doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx', 'rtf', 'pdf'];
        const officeExtensions = ['.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx', '.rtf'];
        
        return officeTypes.includes(filetype) || 
               officeExtensions.some(ext => filename.includes(ext));
    }

    private isRelevantOTXPulse(pulse: any): boolean {
        const tags = pulse.tags?.join(' ').toLowerCase() || '';
        const description = pulse.description?.toLowerCase() || '';
        const name = pulse.name?.toLowerCase() || '';
        
        const relevantKeywords = [
            'microsoft', 'office', '365', 'phishing', 'malware', 'document',
            'email', 'attachment', 'macro', 'vba', 'outlook', 'exchange'
        ];
        
        const searchText = `${tags} ${description} ${name}`;
        return relevantKeywords.some(keyword => searchText.includes(keyword));
    }

    private mapMicrosoftSeverity(severity: string): 'critical' | 'high' | 'medium' | 'low' {
        switch (severity?.toLowerCase()) {
            case 'critical': return 'critical';
            case 'important': return 'high';
            case 'moderate': return 'medium';
            case 'low': return 'low';
            default: return 'medium';
        }
    }

    private mapCVSSSeverity(score: number): 'critical' | 'high' | 'medium' | 'low' {
        if (!score) return 'medium';
        if (score >= 9.0) return 'critical';
        if (score >= 7.0) return 'high';
        if (score >= 4.0) return 'medium';
        return 'low';
    }

    private mapOTXSeverity(tags: string[]): 'critical' | 'high' | 'medium' | 'low' {
        const tagString = tags?.join(' ').toLowerCase() || '';
        
        if (tagString.includes('critical') || tagString.includes('exploit')) return 'critical';
        if (tagString.includes('malware') || tagString.includes('ransomware')) return 'high';
        if (tagString.includes('phishing') || tagString.includes('suspicious')) return 'medium';
        return 'low';
    }

    private extractAffectedProducts(cve: any): string[] {
        const configurations = cve.configurations?.nodes || [];
        const products = new Set<string>();
        
        for (const config of configurations) {
            if (config.cpeMatch) {
                for (const match of config.cpeMatch) {
                    if (match.criteria?.includes('microsoft')) {
                        // Extract product name from CPE
                        const parts = match.criteria.split(':');
                        if (parts.length >= 4) {
                            products.add(parts[3]);
                        }
                    }
                }
            }
        }
        
        return Array.from(products);
    }

    // Event emitters
    private emitNewThreat(indicator: ThreatIndicator): void {
        const event = new CustomEvent('newThreat', { detail: indicator });
        this.eventEmitter.dispatchEvent(event);
    }

    private emitNewSecurityCheck(check: SecurityCheck): void {
        const event = new CustomEvent('newSecurityCheck', { detail: check });
        this.eventEmitter.dispatchEvent(event);
    }

    private emitSourceUpdate(source: ThreatSource, indicatorCount: number): void {
        const event = new CustomEvent('sourceUpdate', { 
            detail: { source: source.name, count: indicatorCount, lastChecked: source.lastChecked }
        });
        this.eventEmitter.dispatchEvent(event);
    }

    private emitError(sourceName: string, error: any): void {
        const event = new CustomEvent('monitoringError', { 
            detail: { source: sourceName, error: error.message || error }
        });
        this.eventEmitter.dispatchEvent(event);
    }

    // Utility methods
    private delay(ms: number): Promise<void> {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    private async sendWebhookAlert(url: string, alert: any): Promise<void> {
        try {
            await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(alert)
            });
        } catch (error) {
            console.error(`Failed to send webhook alert to ${url}:`, error);
        }
    }

    private async storeAlert(alert: any): Promise<void> {
        // Implementation would store in your database
        console.log('üìù Storing threat alert:', alert.title);
    }

    private async storeSecurityCheck(check: SecurityCheck): Promise<void> {
        // Implementation would store in your database
        console.log('üíæ Storing security check:', check.name);
    }

    // Public API methods
    public addWebhook(url: string): void {
        this.webhookUrls.push(url);
    }

    public removeWebhook(url: string): void {
        this.webhookUrls = this.webhookUrls.filter(webhook => webhook !== url);
    }

    public getRecentThreats(hours: number = 24): ThreatIndicator[] {
        const cutoff = new Date();
        cutoff.setHours(cutoff.getHours() - hours);
        
        return Array.from(this.indicators.values())
            .filter(indicator => indicator.detectedAt > cutoff)
            .sort((a, b) => b.detectedAt.getTime() - a.detectedAt.getTime());
    }

    public getSecurityChecks(): SecurityCheck[] {
        return Array.from(this.securityChecks.values())
            .sort((a, b) => b.addedDate.getTime() - a.addedDate.getTime());
    }

    public getSourceStatistics(): Array<{source: string, lastChecked: Date | undefined, isActive: boolean}> {
        return this.sources.map(source => ({
            source: source.name,
            lastChecked: source.lastChecked,
            isActive: source.isActive
        }));
    }

    public addEventListener(type: string, listener: EventListener): void {
        this.eventEmitter.addEventListener(type, listener);
    }

    public removeEventListener(type: string, listener: EventListener): void {
        this.eventEmitter.removeEventListener(type, listener);
    }

    public getIndicatorById(id: string): ThreatIndicator | undefined {
        return this.indicators.get(id);
    }

    public getCheckById(id: string): SecurityCheck | undefined {
        return this.securityChecks.get(id);
    }

    public isMonitoringActive(): boolean {
        return this.isMonitoring;
    }
}

// Export singleton instance
export const threatMonitor = new ThreatIntelligenceMonitor();