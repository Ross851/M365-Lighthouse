import type { APIRoute } from 'astro';

interface RemediationScript {
  id: string;
  title: string;
  description: string;
  script: string;
  parameters?: Record<string, any>;
  requirements?: string[];
}

const remediationScripts: Record<string, RemediationScript> = {
  'enable-mfa-admins': {
    id: 'enable-mfa-admins',
    title: 'Enable MFA for All Admin Accounts',
    description: 'This script enables Multi-Factor Authentication for all administrative accounts in your tenant.',
    requirements: [
      'Global Administrator privileges',
      'MSOnline PowerShell module installed',
      'Connected to Microsoft 365 tenant'
    ],
    script: `# Enable MFA for All Admin Accounts
# Generated by PowerReview Enhanced

# Check if MSOnline module is installed
if (!(Get-Module -ListAvailable -Name MSOnline)) {
    Write-Host "Installing MSOnline module..." -ForegroundColor Yellow
    Install-Module MSOnline -Force -AllowClobber
}

# Import module
Import-Module MSOnline

# Connect to Microsoft 365
Write-Host "Connecting to Microsoft 365..." -ForegroundColor Cyan
Connect-MsolService

# Get all admin role members
$adminRoles = Get-MsolRole | Where-Object {$_.Name -like "*admin*"}
$adminUsers = @()

foreach ($role in $adminRoles) {
    $members = Get-MsolRoleMember -RoleObjectId $role.ObjectId
    $adminUsers += $members
}

# Remove duplicates
$uniqueAdmins = $adminUsers | Select-Object -Property EmailAddress -Unique

Write-Host "Found $($uniqueAdmins.Count) admin accounts" -ForegroundColor Green

# Enable MFA for each admin
foreach ($admin in $uniqueAdmins) {
    try {
        $mfa = New-Object -TypeName Microsoft.Online.Administration.StrongAuthenticationRequirement
        $mfa.RelyingParty = "*"
        $mfa.State = "Enforced"
        
        Set-MsolUser -UserPrincipalName $admin.EmailAddress -StrongAuthenticationRequirements $mfa
        Write-Host "✓ Enabled MFA for $($admin.EmailAddress)" -ForegroundColor Green
    }
    catch {
        Write-Host "✗ Failed to enable MFA for $($admin.EmailAddress): $_" -ForegroundColor Red
    }
}

Write-Host "MFA enforcement complete!" -ForegroundColor Green
Write-Host "Next steps:" -ForegroundColor Yellow
Write-Host "1. Notify admin users to set up their MFA methods"
Write-Host "2. Monitor sign-in logs for any issues"
Write-Host "3. Consider implementing Conditional Access policies"`
  },
  
  'AAD-001-remediate': {
    id: 'AAD-001-remediate',
    title: 'Remediate MFA for All Users',
    description: 'Complete MFA rollout for all users in the organization',
    script: `# Complete MFA Implementation Script
# Phase 1: Enable for privileged users

# Get all users with admin roles or sensitive access
$privilegedUsers = Get-MsolUser -All | Where-Object {
    $_.StrongAuthenticationMethods.Count -eq 0 -and 
    ($_.Title -like "*admin*" -or $_.Title -like "*manager*" -or $_.Department -eq "IT")
}

Write-Host "Phase 1: Enabling MFA for $($privilegedUsers.Count) privileged users..." -ForegroundColor Yellow

foreach ($user in $privilegedUsers) {
    $mfa = New-Object -TypeName Microsoft.Online.Administration.StrongAuthenticationRequirement
    $mfa.RelyingParty = "*"
    $mfa.State = "Enabled"
    
    Set-MsolUser -UserPrincipalName $user.UserPrincipalName -StrongAuthenticationRequirements $mfa
    Write-Host "✓ $($user.DisplayName)" -ForegroundColor Green
}

# Phase 2: Enable for all remaining users
Write-Host "Phase 2: Enable for all remaining users? (Y/N)" -ForegroundColor Yellow
$confirm = Read-Host

if ($confirm -eq 'Y') {
    $remainingUsers = Get-MsolUser -All | Where-Object {$_.StrongAuthenticationMethods.Count -eq 0}
    
    foreach ($user in $remainingUsers) {
        $mfa = New-Object -TypeName Microsoft.Online.Administration.StrongAuthenticationRequirement
        $mfa.RelyingParty = "*"
        $mfa.State = "Enabled"
        
        Set-MsolUser -UserPrincipalName $user.UserPrincipalName -StrongAuthenticationRequirements $mfa
    }
    
    Write-Host "✓ MFA enabled for all users!" -ForegroundColor Green
}`
  },
  
  'block-legacy-auth': {
    id: 'block-legacy-auth',
    title: 'Block Legacy Authentication',
    description: 'Creates a Conditional Access policy to block legacy authentication protocols',
    script: `# Block Legacy Authentication Script
# Requires Azure AD Premium P1 or P2

# Install required module
if (!(Get-Module -ListAvailable -Name AzureAD)) {
    Install-Module AzureAD -Force
}

Import-Module AzureAD
Connect-AzureAD

# Create new Conditional Access policy
$conditions = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessConditionSet
$conditions.Applications = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessApplicationCondition
$conditions.Applications.IncludeApplications = "All"
$conditions.Users = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessUserCondition
$conditions.Users.IncludeUsers = "All"
$conditions.ClientAppTypes = @("ExchangeActiveSync", "Other")

$grantControls = New-Object -TypeName Microsoft.Open.MSGraph.Model.ConditionalAccessGrantControls
$grantControls._Operator = "OR"
$grantControls.BuiltInControls = "Block"

New-AzureADMSConditionalAccessPolicy -DisplayName "Block Legacy Authentication" -State "enabledForReportingButNotEnforced" -Conditions $conditions -GrantControls $grantControls

Write-Host "✓ Policy created in report-only mode" -ForegroundColor Green
Write-Host "Monitor for 7 days before enabling enforcement" -ForegroundColor Yellow`
  },
  
  'configure-sharepoint-dlp': {
    id: 'configure-sharepoint-dlp',
    title: 'Configure SharePoint DLP Policies',
    description: 'Sets up Data Loss Prevention policies for SharePoint and OneDrive',
    script: `# SharePoint DLP Configuration Script
# Requires Security & Compliance PowerShell

# Connect to Security & Compliance Center
$UserCredential = Get-Credential
$Session = New-PSSession -ConfigurationName Microsoft.Exchange -ConnectionUri https://ps.compliance.protection.outlook.com/powershell-liveid/ -Credential $UserCredential -Authentication Basic -AllowRedirection

Import-PSSession $Session -DisableNameChecking

# Create DLP policy for sensitive information
New-DlpPolicy -Name "Protect Sensitive Information" -Mode Enable -ExchangeLocation All -SharePointLocation All -OneDriveLocation All

# Add sensitive information types
$sensitiveTypes = @(
    "U.S. Social Security Number (SSN)",
    "Credit Card Number",
    "U.S. Bank Account Number",
    "U.S. Driver's License Number"
)

foreach ($type in $sensitiveTypes) {
    New-DlpComplianceRule -Name "Block $type" -Policy "Protect Sensitive Information" -ContentContainsSensitiveInformation @{Name=$type; minCount="1"} -BlockAccess $true -NotifyUser Owner -NotifyPolicyTipCustomText "This file contains sensitive information and cannot be shared externally."
}

Write-Host "✓ DLP policies configured successfully" -ForegroundColor Green`
  }
};

export const GET: APIRoute = async ({ url }) => {
  const scriptId = url.searchParams.get('id');
  
  if (!scriptId) {
    return new Response(JSON.stringify({ 
      error: 'Script ID is required' 
    }), {
      status: 400,
      headers: { 'Content-Type': 'application/json' }
    });
  }
  
  const script = remediationScripts[scriptId];
  
  if (!script) {
    // Generate a generic script based on the finding ID
    const genericScript: RemediationScript = {
      id: scriptId,
      title: 'Custom Remediation Script',
      description: 'This is a template for custom remediation',
      script: `# Custom Remediation Script for ${scriptId}
# Generated by PowerReview Enhanced

# TODO: Add your custom remediation logic here
Write-Host "Starting remediation for ${scriptId}..." -ForegroundColor Cyan

# Example structure:
# 1. Connect to required services
# 2. Query current state
# 3. Apply fixes
# 4. Verify changes

Write-Host "Remediation complete!" -ForegroundColor Green`
    };
    
    return new Response(JSON.stringify(genericScript), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    });
  }
  
  return new Response(JSON.stringify(script), {
    status: 200,
    headers: { 'Content-Type': 'application/json' }
  });
};

export const POST: APIRoute = async ({ request }) => {
  try {
    const body = await request.json();
    const { findingId, parameters } = body;
    
    // Generate custom script based on finding details
    const customScript = generateCustomScript(findingId, parameters);
    
    return new Response(JSON.stringify(customScript), {
      status: 200,
      headers: { 'Content-Type': 'application/json' }
    });
  } catch (error) {
    return new Response(JSON.stringify({ 
      error: 'Failed to generate script' 
    }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' }
    });
  }
};

function generateCustomScript(findingId: string, parameters: any): RemediationScript {
  // Logic to generate custom scripts based on finding type
  return {
    id: `custom-${findingId}`,
    title: `Custom Script for ${findingId}`,
    description: 'Automatically generated remediation script',
    script: `# Auto-generated script for ${findingId}
# Parameters: ${JSON.stringify(parameters, null, 2)}

# Implementation goes here...`
  };
}